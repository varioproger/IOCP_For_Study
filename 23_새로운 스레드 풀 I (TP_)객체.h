/*
TP_WORK 콜백 함수를 비동기적으로 호출
TP_WAIT 커널 객체에 신호가 전달되거나 대기 시간이 초과되면 콜백 함수 호출
TP_TIMER 예약 시간에 콜백 함수 호출
TP_IO 비동기 I/O가 완료되면 콜백 함수 호출
TP_POOL 콜백을 실행하는 데 사용되는 스레드의 풀
TP_CALLBACK_ENVIRON 스레드 풀을 해당 콜백 및 선택적으로 정리그룹에 바인딩
TP_CLEANUP_GROUP 한 개 이상의 스레드 풀 콜백 객체 추적

새로운 스레드 풀에 대한 본격적인 설명으로 들어가기 전에 새로운 스레드 풀과 이전 스레드 풀의 중요한 차이를 한 번 더 정리하고 넘어가도록 하자.

  ●   기존 스레드 모델의 함수는 리소스 사용으로부터 리소스 할당을 분리하지 않았다. 이 의미는 이전 스레드 풀은 함수 중심이었음을 의미한다. 
  이러한 리소스 할당은 실패할 우려가 있고 실제로도 종종 실패하기 때문에 기존 함수로는 신뢰성을 보장하는 시스템을 개발하기가 어려웠다. 
  새로운 스레드 풀 함수는 객체 중심의 리소스 할당과 사용을 분리하여 일단 리소스를 성공적으로 할당한 다음, 
  이러한 리소스를 사용하도록 함으로써 오류 발생의 여지를 대폭 줄였다.

  ●   윈도우 2000 모델은 프로세스당 한 개의 스레드 풀(디폴트 스레드 풀)만을 사용할 수 있지만, 
  새로운 모델은 프로세스당 여러 개의 스레드 풀을 만들 수 있다. 이를 통해 구현해야 할 솔루션의 성격에 따라 응용 프로그램이 수행해야 할 작업들을 
  여러 스레드 풀로 분리할 수 있다.

  ●   기존 스레드 풀에서는 I/O 스레드와 Non-I/O 스레드의 두 가지 작업자 스레드 유형을 모두 사용했고, 
  이것은 혼란을 야기시키는 결과를 낳았다. 게다가 두 가지 다른 스레드 그룹이 있다는 것은 다른 유형의 콜백 함수 사이에서 스레드를 공유할 수 없음을 
  의미하기 때문에 스레드 풀 구현의 효율성이 저하되었다. 따라서 새로운 스레드 풀에서는 이러한 구분을 제거했으며, 모든 작업자 스레드는 동일하다.

  ●   기존 스레드 풀 함수 중 QueueUserWorkItem이나 BindIoCompletionCallback의 경우, 작업자 스레드가 언제 콜백 함수의 실행을 완료했는지에 대해 
  응용 프로그램에서 확인할 수 있는 방법은 제공하지 않았다. 또한 스레드 풀의 큐에서 실행되기를 기다리는 콜백 항목을 취소하는 방법이 없어 
  모든 요청이 소진될 때까지 기다릴 수밖에 없었기 때문에 이에 따라 상당한 지연 시간이 발생했으나, 
  새로운 스레드 풀에서는 이를 위한 수단이 제공된다.

이 4개의 카테고리마다 다음과 같이 개별 객체를 별도로 정의하여 제공된다.

  ● 작업(TP_WORK) : 어떤 특정 함수를 비동기적으로 호출하고자 하는 경우
  ● 대기(TP_WAIT) : 임의의 커널 객체가 시그널 되었을 때 반응하기 위해
  ● 타이머(TP_TIMER) : 여러 타이머 군들이 만기되었을 때 반응하기 위해
  ● 입출력(TP_IO) : IOCP의 완료 콜백을 수행하고자 하는 경우

객체를 생성하고 삭제하며 완료 시 실행 중인 콜백 함수의 종료를 기다리기 위한 함수들을 다음의 형태로 제공한다. 
여기에서의 Xxx는 각각 Work, Wait, Timer, Io를 의미한다.

  ● CreateThreadpoolXxx : TP_XXX 객체 생성
  ● CloseThreadpoolXxx : TP_XXX 객체 삭제
  ● WaitForThreadpoolXxxCallback : 콜백 함수 PTP_XXX_CALLBACK의 실행 완료 대기

*/