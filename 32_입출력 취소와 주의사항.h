/*
TP _IO 객체의 경우에는 입출력 완료를 대기하는 처리와 실제 콜백이 수행되는 처리가 분리되어 있다. 
작업 큐에 콜백 항목이 추가되는 상황은 입출력이 완료되었을 때며, 
WaitForThreadpoolIoCallbacks의 역할은 작업 큐에 존재하는 콜백 항목이 존재할 경우 
작업 큐의 항목들에 대해 처리를 취소할 것인지 또는 실행 완료를 대기할 것인지를 결정한다. 
그렇다면 입출력 완료 자체를 대기하는 IOCP 엔트리는 그대로 IOCP 큐에 남아 있는 상태가 된다.
즉 ReadFile이나 WSARecv 등의 함수를 통해 비동기적으로 수신 대기나 읽기 완료 대기 상태에 있는 Pending된 입출력은 여전히 수행 중이며, 
따라서 IOCP 큐에서 입출력이 완료되기를 기다리며 계속 존재하는 상태인 것이다. 
이런 상태에서 입출력 개시 때 넘겨줬던 OVERLAPPED 구조체 항목을 강제로 삭제한다면 문제가 발생되기 때문에, 
따라서 어떻게든 대기 중인 입출력 항목을 취소시켜줘야 한다. 

fCancelPendingCallbacks를 TRUE로 설정한 WaitForThreadpoolIoCallbacks의 호출은 단지 
스레드 풀의 작업 큐에 존재하는 콜백 항목들을 취소할 뿐이다. 
CancelThreadpoolIo 함수도 마찬가지다. 두 함수 모두 작업 큐의 콜백 항목만 취소할 뿐이며, 
실제로 입출력 완료를 대기하는 Pending 입출력 자체를 취소하는 것은 아니다. 
따라서 관련 OVERLAPPED 구조체를 삭제하고자 한다면 반드시 해당 OVERLAPPED 항목과 관련된, 완료 대기 중인 입출력이 완료되었다는 것
을 먼저 보장해주어야 한다. 그러기 위해서는 결국 우리가 앞서 취했던 방식대로 CancelIoEx 함수를 호출하거나 
핸들을 닫아 의도적으로 입출력 완료를 야기시켜 스레드 풀의 작업 큐에 콜백 항목을 추가시키도록 해야 한다. 
그 후 WaitForThreadpoolIoCallbacks를 호출해 의도적인 입출력 완료에 대한 처리 수행이 끝나기를 기다려야 한다. 
따라서 앞의 예에서 먼저 감시 작업 취소를 요청한 후 종료 처리를 하게 하는 것이 낫다.

TP_IO 객체를 사용할 경우 소켓이나 OVERLAPPED 인스턴스를 콜백 함수 내에서 해제하는 것은 가능하지만, 
콜백 항목과 관련된 TP_IO 객체 자체의 해제가 문제될 수 있다.

CloseThreadpoolXxx 함수는 앞서 설명한 것처럼, 현재 실행 중인 콜백 함수가 있을 경우 우선 해제를 표시하고 리턴된다. 
그리고 그 콜백 함수의 실행이 완료되면 스레드 풀은 그 시점에서 TP_XXX 객체를 해제한다.
따라서 앞의 코드의 경우 콜백 함수 내에서 CloseThreadpoolIo를 호출했으므로 콜백 함수는 실행 중인 상태며, 
CloseThreadpoolIo에서 바로 리턴된 다음 곧이어 콜백 함수로부터 리턴되므로, 동적으로 관련 리소스를 해제해야 할 경우에 적절하게 사용될 수 있다. 
주의 할 것은 중첩 입출력이 가능하므로, 콜백 함수 내에서 CloseThreadpoolIo를 호출할 때, 
동시 실행 중인 콜백 함수가 두 개 이상인 경우가 없어야 한다. 
두 개 이상의 콜백이 실행 중이면, 하나의 콜백이 완료된 후 TP_IO 객체가 해제될 시점에 다른 하나의 콜백에서는 
여전히 TP_IO를 사용 중이므로 문제가 발생한다.


TP_IO _2 소스 참조
위의 두 가지 주의사항을 모두 고려하여  AcceptEx 호출 부분을 WSAEventSelect 처리로 변경하고, 
리슨 소켓에 대한 접속은 TP_WAIT 객체를 통해서 처리하며, 자식 소켓의 비동기 수신은 TP_IO 객체를 통해서 처리하도록 변경했다.
*/