/*
입출력 완료 큐에 입출력 완료 패킷이 추가될 경우는
  ●   입출력이 완료되었을 때
  ●   PostQueuedCompletionStatus 함수가 호출되었을 때

IOCP 커널 객체를 다음과 같이 동시 실행 가능 최대 스레드 수를 2로 지정해 생성시켰다고 가정한다.
hIocp =  CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 2);

언제 데이터를 송신할지 알 수 없는 장치(소켓도 좋고 시리얼 포트도 좋다)가 4개 있고,
이 장치를 열었을 때의 핸들값은 각각 hDev0, hDev1, hDev2, hDev3이다. 

이 장치 핸들들을모두 hIocp라는 핸들값을 가진 IOCP에 연결시켰다고 하자. 

그리고 스레드 풀을 위한 스레드를 4개 미리 생성시켜서 실행시켰고, 
이때 스레드 ID를 각각 tid0, tid1, tid2, tid3이라고 하자.

동시 실행 가능한 최대 스레드 수를 2로 지정했기 때문에, 스레드 풀에 존재하는 스레드는 4개지만 
그중 동시에 풀에서 빠져나와 활동할 수 있는 스레드의 수는 최대 2개까지다.

이스레드 엔트리 함수는 장치가 보낼 데이터의 수신 완료 통지를 받기위해 실행되자마자 바로 
GetQueuedCompletionStatus를 호출해서 대기 상태에 있다

장치 리스트 hDev0 -> hDev1 -> hDev2 -> hDev3
입출력 완료 큐에 추가 되는 순은 FIFO로 hDev0 먼저 추가된다.

대기큐 리스트 tid0 -> tid1 -> tid2 -> tid3
입출력 완료 큐에 패킷이 추가되는 순간  IOCP 커널 객체는 대기 스레드 큐의 마지막 엔트리(LIFO이므로)의 스레드를 
대기 스레드 큐로부 터 제거한 후 해제 스레드 리스트에 추가한다.
즉 tid3 먼저 해제 스레드에 추가된다.

IOCP 커널 객체는 입출력 완료 큐로부터 추가된 패킷을 데큐한 후 패킷의 필드들을 
GetQueuedCompletionStatus 함수의 매개변수 pdwNumBytes, CompKey,ppOverlapped에 각각 설정한 후 그 스레드를 깨운다. 
스레드를 깨운다는 의미는 곧GetQueuedCompletionStatus 함수를 리턴시킨다는 의미다. 
이때 리턴값은 TRUE가 되고 정상적으로 입출력이 완료되었음을 의미한다.

깨어난 스레드는 GetQueuedCompletionStatus 함수의 매개변수로부터 데이터와 에러 코드, 입출력 생성키 등을 통해 
해당 처리 작업을 수행한 후 다시 루프를 돌아 GetQueuedCompletionStatus를 호출할 것이다. 
그렇게 되면 스레드는 다시 수면 상태로 들어가게 된다. 현재 이 스레드는 해제 스레드 리스트에 보관되어 있다. 
이 스레드가 다시 GetQueuedCompletionStatus를 호출하면 IOCP커널 객체는 이 스레드를 해제 리스트로부터 제거하여 
대기 스레드 리스트에 푸시한다. 그리고 이 스레드는 입출력 완료 큐가 비어 있는 동안은 계속 대기 상태로 CPU 스케줄링 큐에 추가되지 않는다.


핵심적인 부분은 입출력 완료 큐에 패킷이 존재하고 비록 대기 스레드 큐에 대기 중인 스레드가 존재하더라도 
입출력 완료 큐의 그 패킷은 제거되지 않고 남아 있다. 
즉 여러분이 처음에CreateIoCompletionPort를 통해서 IOCP를 생성할 때 넘겨주는 동시 실행 가능한 최대 스레드수 
이상의 스레드를 실행시키지 않는다는 점이다.

IOCP는 이런 방식으로 동시 실행가능한 스레드의 수를 일정 한도로 제한함으로써 과도한 스레드의 생성 및 사용을 제한한다.


만약 스레드가 입출력 완료에 대한 처리를 수행중일때  WaitForXXX 같은 함수로 인해 대기 상태로 들어갔을때,
IOCP는 잠든 스레 드를 해제 스레드 리스트로부터 제거하고 정지 스레드 리스트에 추가한다. 
이렇게 되면 해제 스레드리스트의 엔트리 수가 감소되어 대기 스레드 큐로부터 스레드를 해제 스레드 리스트에 추가할 수 있게 되고, 
따라서 입출력 완료 큐에 대기 중인 다른 작업을 실행할 수 있게 된다.

해제 스레드 리스트로부터 대기 스레드 큐로의 이동은 그 스레드가 다시GetQueuedCompletionStatus를 호출할 때만 가능하다. 
즉 GetQueuedCompletionStatus를 호출하기 전에 스스로 잠들었을 경우에는 아직 처리 작업이 끝나지 않았기 때문에 
이 스레드를대기 스레드 큐로 옮길 수 없다. 
그래서 이 스레드를 정지 스레드 리스트에 잠시 보관해두기 때문에 빈 자리는 대기 스레드 큐에 있는 다른 스레드가 차지하게 된다.

정지 스레드 리스트의 스레드가 깨어났을 때 해제 스레드 리스트에서 활동 중인 스레드의 수가 여전히 동시 실행 가능한 스레드 수와 같다해도
정지 스레드 리스트에서 깨어난 스레드를 해제 스레드 리스트에 추가한다. 
따라서 이럴 경우에만 동시 실행 가능한 최대 스레드 수보다 많은 스레드가 스레드 풀 밖에서 활동하게 된다. 
이후 해제 스레드 리스트의 수가 감소되더라도 여전히 동시 실행 가능한 스레드 수보다 크거나 같기 때문에,
대기 스레드 큐에 대기중인 스레드가 존재하더라도 더 이상 해제 리스트에 스레드를 추가시키지 않는다.
하지만 IOCP 대기 스레드는 동일한 스레드 엔트리 함수를 사용하는 것이 일반적이다. 
따라서 한 스레드가 대기 상태에 들어가 정지 스레드 리스트에 추가된 후, 
깨어났을 때 해제 스레드 리스트의 수가 동시 실행 가능한 스레드 수와 같을 경우는 별로 없다. 

IOCP의 전제 조건은 입출력 완료 처리를 가능하면 짧은 시간 내에 끝낼 것을 요구한다. 
즉 GetQueuedCompletionStatus로부터 리턴되어 다시 GetQueuedCompletionStatus를 호출하는 그 인터벌이 짧게 끝난다는 전제하에서 가능하다. 
매우 긴 작업 시간을 소요하는 경우라면 IOCP의 사용을 피하고 별도의 명시적 스레드를 생성해서 처리하는 것이 상책이다.

보통 알려진 대로 동시성 값의 두 배만큼 풀 내의 스레드 수를 생성하는 것이 관례다. 
따라서 NumberOfConcurrentThreads를 0으로 지정했다면 윈도우는 동시성 값을 CPU 수만큼 지정할 것이기 때문에, 
여러분은 IOCP에 대해 대기할 스레드의 수를 CPU 수×2만큼 생성하면 될 것이다.

*/